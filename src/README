# -- -- -- -- -- -- -- -- -- -- -- -- -- --
#. Code structure
# -- -- -- -- -- -- -- -- -- -- -- -- -- --

All explanations assume you start from uquad/src/

Main:	The main control loop is main/main.c. See main/README for more info.
	It will consists of a loop in which:
	   - all the io devices are polled.
	   - those input devices with data ready are handled (new data is read)
	   - the state estimation is updated with the new data
	   - actions are performed in order to achieve whatever goal has been set (hover, go forward, track an object, etc)

Devices: Each device should have it's own API, in a separate folder (example: imu/).
	 A control loop will check with device has data available, and read only from the devices that do have data, avoiding locking. this is done via select().
	 Each device should provide a way to access their file descriptor, and a function to update/read data once it is available.

Common:	 Code that can be used in a general context (several devices, control loop, etc) such as io, error handling, logging, etc goes in common/

Test programs:
     Test programs have their individual directory within test/

Build system:
      Build system is based on cmake. Instruction follow on how to get it running without reading much.
      Basic intro: http://mathnathan.com/2010/07/11/getting-started-with-cmake/

# -- -- -- -- -- -- -- -- -- -- -- -- -- --
#. CMake basics
# -- -- -- -- -- -- -- -- -- -- -- -- -- --
cmake will parse CMakeLists.txt, and dig into any directories listed as:
   add_subdirectory(dir_name)
It will search for headers in the directories (separated by spaces) listed in:
   include_directories(dir1 dir2)

Each subdirectory has a CMakeLists.txt of its own, that can point deeper into the tree.

# -- -- -- -- -- -- -- -- -- -- -- -- -- --
#. Setting up the build system
# -- -- -- -- -- -- -- -- -- -- -- -- -- --
To setup the build system do
   sh run_cmake.sh
   

Optional arguments to the script are:
   - debug: Will build code with debug symbols.
   - arm: Use cross compiler, generate code that will run on the beagle.
   - help: Show possible arguments.

This will setup everything in src/build/
To compile a test program, for example imu_comm_test
   cd build/
   make imu_comm_test

You will find the output in src/build/test/imu_comm_test

# -- -- -- -- -- -- -- -- -- -- -- -- -- --
#. Cross compiling
# -- -- -- -- -- -- -- -- -- -- -- -- -- --
To cross compile code, a toolchain must be available on the system.
If you're using openembedded+bitbake, then you probably have one lying around.
Everytime you open a console, the file ~/.bashrc is loaded. Set an environment variable to point to your toolchain in your ~/.bashrc by adding this line:
    export OE_BEAGLE_TOOLCHAIN=$OE_BUILD_TMPDIR/sysroots/x86_64-linux/usr/armv7a/bin

The variable OE_BUILD_TMPDIR should have been set by openembedded in ~/.oe/environment-2008
I recommend adding this line to your ~/.bashrc before the line defining OE_BEAGLE_TOOLCHAIN. It will load all the variables defined by openembedded into every console you open:
    source ~/.oe/environment-2008

# -- -- -- -- -- -- -- -- -- -- -- -- -- --
#. Adding a new test program:
# -- -- -- -- -- -- -- -- -- -- -- -- -- --
- Create a new dir:
  mkdir test/new_test
  cd test/new_test
  cp ../imu_comm_test/CMakeLists.txt .

- Add the new directory to cmake's subdirs by editing test/CMakeLists.txt
      before editing:
      	     add_subdirectory(imu_comm_test)
      after editing:
      	     add_subdirectory(imu_comm_test new_test)

Edit the CMakeLists.txt in new_test/ according to your needs:
     - Set the program name
     - List the required libraries.

# -- -- -- -- -- -- -- -- -- -- -- -- -- --
#. Refs
# -- -- -- -- -- -- -- -- -- -- -- -- -- --

- http://www.cmake.org/cmake/help/cmake-2-8-docs.html#module:ExternalProject