\documentclass[main]{subfiles}

\begin{document}

\chapter{Configuraci\'on y compilaci\'on del c\'odigo}
\label{chap:anexo-codigo}

En este anexo se explican los conceptos b\'asicos necesarios para trabajar con la \textit{BeagleBoard}.

\subsection{Obtenci\'on del c\'odigo - Git}
\label{sec:codigo:git}

El código está almacenado en un repositorio git disponible en el DVD adjunto a esta documentación y en \textit{github}: \url{git://github.com/rlrosa/uquad.git}. El repositorio ocupa aproximadamente 4GB, por lo que no es conveniente poner otras cosas en la tarjeta SD de la Beagleboard, ya que sino se excederá su capacidad.

\subsection{Comunicación con la \textit{BeagleBoard}}
\label{sec:codigo:comunicacion}

La forma básica de comunicarse con la Beagleboard es mediante el puerto serie, usando un conversor \textit{RS2232} a USB. Durante el vuelo, la comunicación se establece mediante \textit{WiFi}, usando un dongle USB. El procedimiento para hacerlo funcionar es el siguiente:

\begin{enumerate}
\item Copiar el firmware \verb+scripts/rt73.bin+ a la Beagleboard en \verb+/lib/firmware/+.
\item Instalar el software necesario haciendo \newline\verb+opkg install kernel-module-rt73usb rt73-firmware+.
\end{enumerate}

Una forma de conectarse es usando una red \textit{Ad-Hoc}, aunque también se puede utilizar un servidor \textit{DHCP}. Para configurar la interfaz \verb+wlan0+\footnote{El dongle puede ser asociado a otra interfaz, como \textit{wlan1}, configurar la apropiada.} para trabajar en modo \textit{Ad-Hoc} agregar las siguiente líneas a \verb+/etc/network/interfaces+:
\begin{quote}
\begin{verbatim}
auto wlan0
iface wlan0 inet static
address 10.42.43.2
netmask 255.255.255.0
wireless-mode ad-hoc
wireless-essid uquad
wireless-key s:uquaduquad123
\end{verbatim}
\end{quote}

Luego, levantar una red en una laptop, en modo \textit{Ad-Hoc}, con nombre \textit{uquad} y contraseña \textit{uquaduquad123} en \textit{WEP 40/128-bit Key(Hex or ASCII)}. La laptop tendrá la IP \textit{10.42.43.1}, y la Beagleboard \textit{10.42.43.2}. El usuario en la Beagleboard es \textit{root} y la clave cualquiera. Para conectarse ver la subsección sobre \textbf{ssh}.

\subsubsection{Ssh}
\label{sec:codigo:ssh}

El usuario \textit{root} acepta cualquier contraseña. Para evitar que la Beagleboard pida contraseña, se puede agregar la clave pública de una laptop a la Beagleboard, en\footnote{Crear el archivo y/o el directorio, si estos no existen.}.:
\begin{quote}
\begin{verbatim}
/home/root/.ssh/authorized_keys
\end{verbatim}
\end{quote}

Para conectarse hacer:
\begin{quote}
\begin{verbatim}
ssh root@10.42.43.2
\end{verbatim}
\end{quote}


\subsubsection{Ethernet}
\label{sec:codigo:ethernet}

La Beagleboard sabe conectarse a una red en la que haya un servidor \textit{DHCP}. Elegirle un nombre en \verb+/etc/hostname+, por ejemplo \textit{beagle}, y luego hacer:
\begin{quote}
\begin{verbatim}
ssh root@beagle.local
\end{verbatim}
\end{quote}

\subsubsection{Configuraci\'on del proxy}
\label{sec:codigo:proxy}

Para trabajar con la Beagleboard en el laboratorio de medidas, es necesario configurar el proxy. Para ello, ejecutar los siguiente comandos en la Beagleboard:
\begin{quote}
\begin{verbatim}
echo "option http_proxy http://httpproxy.fing.edu.uy:3128/" \
>> /etc/network/options.conf
echo "option http_proxy http://httpproxy.fing.edu.uy:3128/" \
>> /etc/opkg/arch.conf
\end{verbatim}
\end{quote}

\subsection{Tiempos}
\label{sec:codigo:tiempos}

El \textit{main} corre sobre linux, lo cual simplifica algunas cosas, pero complica otras. Correr arriba de un sistema operativo que no es RT\footnote{RealTime.} inevitablemente introduce demoras. Se configura el \textit{main} y el driver de los motores para tener m\'axima prioridad.

La performance del \textit{main} es \textbf{INACCEPTABLE} si se accede a memoria no vol\'atil o si se abren sesiones ssh durante su ejecución.

\subsection{Consideraciones de seguridad}
\label{sec:codigo:consideraciones-de-seguridad}

Al comenzar el \textit{main}, intentará establecer una conexión TCP con un servidor en la laptop, y abortará en caso de no tener éxito. Si en algún momento se pierde la conexión, por ejemplo por algún error en el driver del dongle \textit{WiFi}, el \textit{main} abortará, apagando los motores del cuadricóptero. Para iniciar el servidor en la laptop ubicarse en el directorio \verb+src/build/check_net+ y ejecutar \verb+./server+.\\

En caso de perderse ls conexión ssh, y que el cuadricóptero siga funcionando (porque la conexión TCP sigue abierta), se puede detener el servidor que corre en la laptop, lo cual hará que el \textit{main} aborte y apague los motores.\\

El \textit{main} verifica que la inclinaci\'on del cuadric\'optero no supere cierto l\'imites durante un tiempo dado. Si esto sucede, apagar\'a los motores. Esto puede ser \'util si por alg\'un motivo se pierde el control mediante software, pero se puede acceder al cuadric\'optero, ya que inclin\'andolo lo suficiente se apagar\'ian los motores.\\

El driver de los motores (\textit{cmd}) tiene que estar funcionando para que los motores permanezcan prendidos. La p\'erdida de energ\'ia en la \textit{BeagleBoard} detendr\'ia al driver, y por lo tanto tambi\'en a los motores (El frenado tardar\'ia unos segundos, ya que se omitir\'ia la secuencia de frenado).

\section{Salida - Logs}
\label{salidas-logs}

El \textit{main} genera varios logs durante su ejecución, que sirven como realimentación al usuario para determinar la causa de errores o comportamientos extraños durante un vuelo:
\begin{itemize}
\item Datos crudos provenientes de la IMU: \textit{imu\_raw.log}
\item Datos utilizados para estimar el estado: \textit{kalman\_in.log}
\item Estado estimado: \textit{x\_hat.log}
\item Acción de control: \textit{w.log}
\end{itemize}

La primer columna de \textit{imu\_raw.log}, \textit{kalman\_in.log} y \textit{w.log} es el tiempo en segundos desde el comienzo del \textit{main}. La diferencia de tiempo entre \textit{kalman\_in.log} y \textit{x\_hat.log} es despreciable, por lo que \textit{x\_hat.log} no tiene columna de tiempos. Referirse al código fuente por información sobre como habilitar logs, nombres, contenido, etc.\\

Por cada log se crea un programa independiente (de ahora en m\'as \textit{logger}), que se comunica con el \textit{main} mediante \textit{pipes}. Cada logger tiene un espacio limitado en RAM (definido al iniciar el \textit{logger}), donde ir\'a almacenando lo que reciba del \textit{main}. Cuando el espacio se acabe dejará de guardar información, mostrando una alerta en la consola. Solamente se escribir\'a a disco al finalizar la ejecuci\'on del \textit{main}. Los logs se guardar\'an, por defecto, a \verb+/media/sda1/+, una memoria flash comercial. Si no se dispone de una memoria flash se puede modificar los argumentos de arranque del \textit{main} para que guarde en otro lado. Esto se implement\'o para evitar la escritura a la tarjeta \textit{microSD}, que es muy lenta y hace inaceptable la performance del \textit{main}\footnote{Dado que la versi\'on actual del \textit{logger} no accede a disco hasta que termina de ejecutarse el \textit{main}, no deber\'ia ser un problema guardar a la \textit{microSD}. Esto no ha sido probado.
}.\\

\section{Debugging}
\label{sec:codigo:debugging}

Para probar el \textit{main} sin volar el cuadricóptero, puede resultar cómodo apagar el control de connectividad. Para ello, setear \verb+CHECK_NET_BYPASS+ a 1 en
\begin{quote}
\begin{verbatim}
src/common/uquad_config.h
\end{verbatim}
\end{quote}

ADVERTENCIA: \textbf{NO} es recomendable hacer esto para una prueba con los motores prendidos, ya que la pérdida conexión implicaría la pérdida del control sobre el cuadricóptero.

\subsection{Ejecución a partir de un log}
\label{sec:codigo:ejecucion-a-partir-de-un-log}

Para debuggear el \textit{main}, se lo puede correr con un log conocido como entrada, lo cual permite analizar el efecto de cambios concretos. Para esto se debe configurar el módulo que lee de la IMU, avisándole que debe leer de un log. Esto se logra seteando \verb+IMU_COMM_FAKE+ a 1, en \verb+src/imu/imu_comm.h+.

\subsubsection{C Vs. MatLab}
\label{sec:codigo:c-vs-matlab}

Existe un script en \textit{MatLab} que reproduce el comportamiento del \textit{main}. Es muy útil para hacer pruebas y verificar el correcto funcionamiento del código en \verb+C+:

\begin{quote}
\begin{verbatim}
kalman/kalman_main.m
\end{verbatim}
\end{quote}

Como argumento toma un log de datos crudos de la imu (\textit{imu\_raw.log}), como los generados por el \textit{main} o por \textit{imu\_comm\_test}:
\begin{quote}
\begin{verbatim}
src/test/imu_comm_test/imu_comm_test.c
\end{verbatim}
\end{quote}

\section{Kernel}
\label{sec:codigo:kernel}

La Beagleboard corre linux \textit{2.6.37}, de la distribución \textit{Angstrom}:
\begin{itemize}
\item \url{http://www.angstrom-distribution.org/}
\end{itemize}
El kernel que viene por defecto es suficiente para \textit{casi} todo. Solo hace falta configurar el puerto \textit{i2c-2} para que trabaje a 333kHz (en lugar de 400kHz).\\

Para compilar el kernel se utilizó \textit{Bitbake+OpenEmbedded}, y se lo compiló desde \textit{Ubuntu} 11.10 (64bits).\\

La información que se presenta a continuación se obtuvo de \cite{bib:oe-capture-changes}, \cite{bib:oe-angstrom-kernel-workflow} y del canal IRC \verb+#oe+.

\subsection{\textit{Compilación: Bitbake+OpenEmbedded}}
\label{sec:codigo:cross-compiling-bitbake-oe}

Para poder compilar programas para la Beagleboard se puede usar un entorno de desarrollo como OpenEmbedded (de ahora en más \textit{OE}) y la herramienta para compilar, \textit{bitbake}. La herramienta \textit{bitbake} maneja recetas que listan programas y sus dependencias, y se encarga de compilar las cosas en el orden apropiado.\\

Todo lo que usa \textit{OE} se baja de internet mediante \textit{git}. A veces hay problemas con los servidores, y es cuestión de probar nuevamente en otro momento (o cambiar de servidor, revisar proxy, etc). Compilar una imagen entera, como para una SD, no es fácil, lleva tiempo, requiere que todos los servidores funcionen y un poco de suerte.\\

Para compilar en \textit{Ubuntu}:
\begin{enumerate}
\item Ejecutar \verb+sudo dpkg-reconfigure dash+ y en el menu elegir la opción \textit{no}. Por más información ver\newline\url{http://wiki.openembedded.org/index.php/OEandYourDistro}.
\item Descargar, configurar y actualizar el repositorio:
\begin{quote}
\begin{verbatim}
git clone git://git.angstrom-distribution.org/setup-scripts
cd startup-scripts
MACHINE=Beagleboard ./oebb.sh config Beagleboard
MACHINE=Beagleboard ./oebb.sh update
source ~/.oe/environment-oecore
\end{verbatim}
\end{quote}
\item Si se quisiera compilar ahora\footnote{Compilar la imagen lleva mucho tiempo, mejor configurar todo antes de compilar.}, hacer:
\begin{quote}
\begin{verbatim}
bitbake console-image
\end{verbatim}
\end{quote}
\end{enumerate}

El script \verb+~/.oe/environment-oecore+ es responsable de generar variables que se utilizan durante la compilación. Cada vez que se abre una consola se cargan las variables globales y las declaradas en \verb+~/.bashrc+, una almacena las rutas a los ejecutables instalados, otra las bibliotecas, etc. Las variables en \verb+~/.oe/environment-oecore+ hay que cargarlas cada vez que se abre una nueva consola. Una de las cosas que hace el script es indicar la ruta al programa \textit{bitbake}. Para verificar que el script fue correctamente ejecutado se puede escribir el comienzo del comando \verb+bit+ y apretar \textit{tab} para ver sugerencias. Entre las opciones debería aparecer el comando \textit{bitbake}.\\

Las recetas que utiliza \textit{bitbake} (y nos interesan más) se encuentran en:
\begin{quote}
\begin{verbatim}
setup_scripts/sources/meta-ti/
\end{verbatim}
\end{quote}
Algunos ejemplos:
\begin{itemize}
\item Configuración del kernel:
\begin{verbatim}
setup-scripts/sources/meta-ti/recipes-kernel/\
linux/linux-3.0/Beagleboard/defconfig
\end{verbatim}
\item Receta para el kernel:
\begin{verbatim}
setup_scripts/sources/meta-ti/recipes-kernel/\
linux/linux-omap_3.0.bb
\end{verbatim}
\item Receta para el u-boot:
\begin{verbatim}
setup-scripts/sources/meta-ti/recipes-bsp/\
u-boot/u-boot_2011.12.bb
\end{verbatim}
\end{itemize}

Luego de haber incorporado las variables de \verb+~/.oe/environment-oecore+ ya no es necesario usar \verb+MACHINE=Beagleboard ./oebb.sh+, se puede y debe usar directamente \textit{bitbake}.\\

Es recomendable hacer \verb+MACHINE=Beagleboard ./oebb.sh update+ frecuentemente.
Algunos paquetes necesarios para poder compilar correctamente (pueden faltar otros):
\begin{quote}
\begin{verbatim}
sudo apt-get install\
   python-ply python-progressbar\
   texi2html cvs subversion gawk\
   chrpath texinfo diffstat
\end{verbatim}
\end{quote}

\subsubsection{Como modificar el contenido de OE}
\label{sec:codigo:como-modificar-el-contenido-de-oe}

Para modificar un programa, como por ejemplo el \textit{u-boot}:
\begin{quote}
\begin{verbatim}
bitbake -c devshell u-boot
# se abre una consola en el dir temporal del u-boot
emacs board/ti/beagle/beagle.h
# editar, por ejemplo habilitar la UART2
git add board/ti/beagle/beagle.h
git commit -m 'uquad: habilitando UART2'
git format-patch HEAD~1
cp 001-uquad:-habilitando-UART2.patch $OE_BASE/
# incrementar la línea que dice "PR = "r4"", ponerle r5
bitbake u-boot
# buscar el resultado en setup-scripts/build/tmp*/deploy/images
\end{verbatim}
\end{quote}

Para modificar el kernel y setear el \textit{i2c-2} a 333kHz:

\begin{quote}
\begin{verbatim}
bitbake -c devshell virtual/kernel
# se abre una cosola en el dir temporal del kernel
# ANTES de cambiar nada, hacer:
quilt new uquad-set-i2c-2-333kHz.patch
# Si se quiere hacer cambios en board-omap3beagle.c:
quilt add arch/arm/mach-omap2/board-omap3beagle.c
emacs arch/arm/mach-omap2/board-omap3beagle.c
# editar, por ejemplo setear i2c a 333kHz
# Ahora pedirle a quilt que arme un patch
quilt refresh
# El patch queda en patches/uquad-set-i2c-2-333kHz.patch
# Se copia a meta-ti/recipes-kernel/linux-3.0/
# Se edita meta-ti/recipes-kernel/linux_3.0.bb, agregando una
# línea antes de la q dice defconfig:
file://uquad-set-i2c-2-333kHz.patch;patch=1 \
# Ahora se compila haciendo
bitbake virtual/kernel
\end{verbatim}
\end{quote}

\subsubsection{Comandos útiles - \textit{bitbake}+OE}
\label{sec:codigo:comandos-bitbake-oe}

Algunos comando que pueden ser de utilidad:

\begin{itemize}
\item Para compilar un paquete individual, sin tomar en cuenta las dependencias:
\begin{verbatim}
bitbake -b receta.bb
\end{verbatim}
Ejemplo:
\begin{verbatim}
bitbake -b sources/meta-ti/recipes-bsp/u-boot/u-boot_2011.12.bb
\end{verbatim}
\item Para ver todas las recetas que se ejecutan como dependencias, hacer:
\begin{verbatim}
bitbake <receta> -g
\end{verbatim}
y luego mirar en \verb+task-depends.dot+.

Ejemplo:
\begin{verbatim}
bitbake console-base-image -g
\end{verbatim}
\item Para borrar todo lo compilado sobre un paquete, por ejemplo el u-boot, hacer:
\begin{verbatim}
bitbake -c clean u-boot
\end{verbatim}
\end{itemize}

\section{IMU}
\label{sec:codigo:imu}

La Mongoose viene cargada con un \textit{bootloader} \textit{Arduino}, que permite bajarle código mediante el puerto serie.\\

\subsection{Compilación}
\label{sec:codigo:compilacion-mongoose}

Para programar la Mongoose se utiliza \textit{Arduino}. Para instalarlo hacer:
\begin{quote}
\begin{verbatim}
sudo apt-get install arduino
\end{verbatim}
\end{quote}

El código utiliza una biblioteca que no viene con \textit{Arduino}. Asumiendo que el repositorio git fue descargado a \verb+~/uquad+, para agregar la biblioteca al \textit{Arduino}, hacer:
\begin{quote}
\begin{verbatim}
sudo ln -s ${HOME}/uquad/src/mongoose_fw/HMC58X3/\
 /usr/share/arduino/libraries/HMC58X3
\end{verbatim}
\end{quote}

\section{Trabajo a futuro}
\label{sec:codigo:trabajo-a-futuro}

\begin{itemize}
\item \textbf{Path planner:} Solamente está implementada la modalidad de \textit{hovering}. Queda pendiente implementar rectas y círculos, y un sistema de \textit{waypoints} que permita ir recorriendo trayectorias.
\item \textbf{Control:} La matriz de control se carga de un archivo de texto. Para automatizar el cálculo de dicha matriz, permitiendo cambiar de trayectoria en tiempo real, habría que calcularla en \verb+C+.\newline
En \verb+src/control/control.c+ está lista una implementación del algoritmo LQR, y de la linealización del sistema según la trayectoria elegida. Se verific\'o el correcto funcionamiento de la implementaci\'on comparando contra la versi\'on en \textit{MatLab}, pero no se lo incorpor\'o al \textit{main}.\newline
Un tema a considerar es el tiempo de computo, varios segundos seg\'un pruebas en una PC. Esto ser\'ia inaceptable durante el vuelo. Una soluci\'on simple ser\'ia hacer las cuentas de a poco, evitando pasar varios segundos sin ejecutar acciones de control.
\item \textbf{Visión:} Queda pendiente implementar en \verb+C+ el algoritmo descrito en \ref{chap:camara}.
\item \textbf{Logger:} Una mejora sería que el \textit{logger} guarde información en binario en lugar de usar \verb+ASCII+, lo que permitiría ahorrar RAM. De cualquier forma, el RAM no es un problema por el momento.
\end{itemize}
%TODO
% no esta implementado el path planner
% no anda bien lo de la matriz K en C, en realidad lo de la linealizacion (capaz es choto)

\end{document}